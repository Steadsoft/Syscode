
/* Unit test input to ensure error free parse testing        */
/* and pushing the grammar's limits with respect             */
/* keyword identifiers, statement splittig and termination.  */

/* 
    block comment with newlines in
*/



/* declarations */

/* alignment */
/* when applied to a struct the attributes is applied to every contained member that does not have an explicit */
/* alignment */

/#

dcl variable bin8; 
dcl array(10) bin(22)
dcl counters(100) dec(10) unaligned
dcl target label

scope systems.support

end /* scope */

#/

dcl array(10) bin8

@i_am_a_place

@i_am_a_place(3) 

call reboot(9)

goto i_am_a_place(5)

goto i_am_a_place(target)

dcl struct bin(99)

dcl test(100,100) aligned 
        bulk
            charlie      bin8
            aligned bin8 
        end
    block (a,b) 
       inner

       end
    end
    collect 

    end

    
    charlie(x,y) bin8 aligned // comment     
    charlie bin8
    charlie bin8
    aligned bin16

    aligned aligned

    end

    charlie bin8

end

type isr_register
     mode     bit(2)
     max      bit(3)
     mas      bit(9)
end

dcl dcl (10) string(44)

dcl target label

target = that_other_label

goto target

dcl  handler(32) entry(bin8, string)

call handler(J)(10,"hello")

/#


type A
        B
            counter bin8
            lister  bin8
        end 
       printer bin8
end

  

type control_block(10) aligned
       header string (32)
       list_length bin (16) unaligned
end /* struct */

dcl overlay control_block const;

procedure startup (arg1,arg2,arg3)

    return 

end   /* proc  */

/* some procedures */

@this_is_another_label

procedure shutdown 

    if a = b then
       return
    end

end /* proc */

/* another sope block */

scope utilities

proc reset_page_table (table_ptr)

    if then >= proc then
       call = return
    else
       elif = call (if)
    end

    call startup (1,2,3)

    return doomsday

end /* proc */

struct struct
       bin8 bin8
       if   string(16)
       then dec(10)
       else bit(24)
       dcl  bin32
       end  bin64 aligned
end /* struct */
   



name.other(1,2,3)(a,b,c) = 123 



name(1,2,3).other(a,b,c) = 123

return speed * scale + length




while (expression) 

end

until (expression) 

end 



for x = a to b by c  

end

for x = 100 to 100 
 while (size < 100)

end

for x = 100 to 100 
 until (size < 100)

end

for x = 100 to 100 
 while (running) 
 until (size < 100)

end
for x = 100 to 100 
 until (running) 
 while size < 100

end

while (still_time) until no_space_left

end

until (still_time) while no_space_left  // In the AST a while loop with an until condition should be treated as indistinguishable from a until loop with a while condition

end

while (still_time) 
   until no_space_left
      fast = slow
   end
end

for a = 10 to 1000
    while (c < x)
       count = effoff(s)
    end
end   

for a = 10 to 1000
    while (c < x)
       count = effoff(s)
end    

a = <& G        // and all the bits in G
b = <| b
v = <^ Julia

bits &= 5
bits |= 10
bits ^= 100

bits <<= 5
bits >>= 7

bite @>= 3  // bits = bits @> 3
bits <@= 5  // bits = bits <@ 5


/*


 




end /* scope */

*/
a = 4

#/
